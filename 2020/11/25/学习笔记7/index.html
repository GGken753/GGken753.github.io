<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>MISC解题思路 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="&#x2F;&#x2F;借鉴于https:&#x2F;&#x2F;www.cnblogs.com&#x2F;-chenxs&#x2F;p&#x2F;11493898.html和https:&#x2F;&#x2F;www.cnblogs.com&#x2F;NPFS&#x2F;p&#x2F;13383625.html大佬的介绍和解题思路隐写术图像隐写术进行数据隐写分为以下几类： 1.在图片右击查看属性，在详细信息中隐藏数据 2.将数据类型进行改写（rar或者zip数据改为jpg等格式） 3.根据各种类型图像的固定格式，">
<meta property="og:type" content="article">
<meta property="og:title" content="MISC解题思路">
<meta property="og:url" content="http://ggken753.github.io/2020/11/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="&#x2F;&#x2F;借鉴于https:&#x2F;&#x2F;www.cnblogs.com&#x2F;-chenxs&#x2F;p&#x2F;11493898.html和https:&#x2F;&#x2F;www.cnblogs.com&#x2F;NPFS&#x2F;p&#x2F;13383625.html大佬的介绍和解题思路隐写术图像隐写术进行数据隐写分为以下几类： 1.在图片右击查看属性，在详细信息中隐藏数据 2.将数据类型进行改写（rar或者zip数据改为jpg等格式） 3.根据各种类型图像的固定格式，">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gitee.com/lin-ziyang/hexo/raw/master/1999159-20200712082911929-729980764.png">
<meta property="article:published_time" content="2020-11-25T08:20:44.808Z">
<meta property="article:modified_time" content="2020-11-26T12:31:03.520Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/lin-ziyang/hexo/raw/master/1999159-20200712082911929-729980764.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://GGken753.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-学习笔记7" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07/" class="article-date">
  <time datetime="2020-11-25T08:20:44.808Z" itemprop="datePublished">2020-11-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      MISC解题思路
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="借鉴于https-www-cnblogs-com-chenxs-p-11493898-html和https-www-cnblogs-com-NPFS-p-13383625-html大佬的介绍和解题思路"><a href="#借鉴于https-www-cnblogs-com-chenxs-p-11493898-html和https-www-cnblogs-com-NPFS-p-13383625-html大佬的介绍和解题思路" class="headerlink" title="//借鉴于https://www.cnblogs.com/-chenxs/p/11493898.html和https://www.cnblogs.com/NPFS/p/13383625.html大佬的介绍和解题思路"></a>//借鉴于<a target="_blank" rel="noopener" href="https://www.cnblogs.com/-chenxs/p/11493898.html%E5%92%8Chttps://www.cnblogs.com/NPFS/p/13383625.html%E5%A4%A7%E4%BD%AC%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF">https://www.cnblogs.com/-chenxs/p/11493898.html和https://www.cnblogs.com/NPFS/p/13383625.html大佬的介绍和解题思路</a></h2><h2 id="隐写术"><a href="#隐写术" class="headerlink" title="隐写术"></a>隐写术</h2><h3 id="图像隐写术进行数据隐写分为以下几类："><a href="#图像隐写术进行数据隐写分为以下几类：" class="headerlink" title="图像隐写术进行数据隐写分为以下几类："></a>图像隐写术进行数据隐写分为以下几类：</h3><ul>
<li>1.在图片右击查看属性，在详细信息中隐藏数据</li>
<li>2.将数据类型进行改写（rar或者zip数据改为jpg等格式）</li>
<li>3.根据各种类型图像的固定格式，隐藏数据</li>
<li>在编译器中修改图像开始的标志，改变其原来图像格式</li>
<li>在图像结束标志后加入数据</li>
<li>在图像数据中加入数据，不影响视觉效果情况下修改像素数据，加入信息</li>
<li>4.利用隐写算法将数据隐写到图片中而不影响图像（仅限于jpg图像） 隐写常用的算法有F5，guess jsteg jphide。</li>
</ul>
<h3 id="破解隐写术方法及步骤"><a href="#破解隐写术方法及步骤" class="headerlink" title="破解隐写术方法及步骤"></a>破解隐写术方法及步骤</h3><ul>
<li><p>1.查看图像属性详细信息是否有隐藏内容</p>
</li>
<li><p>2.利用winhex或nodepad++打开搜索ctf,CTF，flag,key等关键字是否存在相关信息</p>
</li>
<li><p>3.检查图像的开头标志和结束标志是否正确，若不正确修改图像标志恢复图像，打开查看是否有flag或ctf信息，（往往gif属于动图，需要分帧查看各帧图像组合所得数据 若不是直接的ctf或flag信息 需要考虑将其解码）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- jpg图像开始标志：FF D8 结束标志 ：FF D9</span><br><span class="line">- gif图像开始标志：47 49 46 38 39 61 (GIF89)结束标志：01 01 00 3B</span><br><span class="line">- bmp图片开始标志：42 4D &#x2F;&#x2F;92 5B 54 00 00 00 00 00 结束标志：00</span><br><span class="line">- png图片开始标志：89 50 结束标志：60 82</span><br><span class="line">- TIFF (tif)开始标志：49 49 2A 00</span><br><span class="line">- Windows Bitmap (bmp)开始标志：42 4D</span><br><span class="line">- CAD (dwg)开始标志：41 43 31 30</span><br><span class="line">- Adobe Photoshop (psd)开始标志：38 42 50 53</span><br><span class="line">- Rich Text Format (rtf)开始标志：7B 5C 72 74 66</span><br><span class="line">- XML (xml)开始标志：3C 3F 78 6D 6C</span><br><span class="line">- HTML (html)开始标志：68 74 6D 6C 3E</span><br><span class="line">- Email [thorough only] (eml)开始标志：44 65 6C 69 76 65 72 79 2D 64 61 74 65 3A</span><br><span class="line">- Outlook Express (dbx)开始标志：CF AD 12 FE C5 FD 74 6F</span><br><span class="line">- Outlook (pst)开始标志：21 42 44 4E</span><br><span class="line">- MS Word&#x2F;Excel (xls.or.doc)开始标志：D0 CF 11 E0</span><br><span class="line">- MS Access (mdb)开始标志：53 74 61 6E 64 61 72 64 20 4A</span><br><span class="line">- WordPerfect (wpd)开始标志：FF 57 50 43</span><br><span class="line">- Postscript (eps.or.ps)开始标志：25 21 50 53 2D 41 64 6F 62 65</span><br><span class="line">- Adobe Acrobat (pdf)开始标志：25 50 44 46 2D 31 2E</span><br><span class="line">- Quicken (qdf)开始标志：AC 9E BD 8F</span><br><span class="line">- Windows Password (pwl)开始标志：E3 82 85 96</span><br><span class="line">- ZIP Archive (zip)开始标志：50 4B 03 04  结束标志：50 4B</span><br><span class="line">- RAR Archive (rar)开始标志：52 61 72 21</span><br><span class="line">- Wave (wav)开始标志：57 41 56 45</span><br><span class="line">- AVI (avi)开始标志：41 56 49 20</span><br><span class="line">- Real Audio (ram)开始标志：2E 72 61 FD</span><br><span class="line">- Real Media (rm)开始标志：2E 52 4D 46</span><br><span class="line">- MPEG (mpg)开始标志：00 00 01 BA</span><br><span class="line">- MPEG (mpg)开始标志：00 00 01 B3</span><br><span class="line">- Quicktime (mov)开始标志：6D 6F 6F 76</span><br><span class="line">- Windows Media (asf)开始标志：30 26 B2 75 8E 66 CF 11</span><br><span class="line">- MIDI (mid开始标志：4D 54 68 64</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>4.将图片放置在kail系统中，执行binwalk xxx.jpg 查看图片中是否是多个图像组合或者包含其他文件（若存在多幅图像组合，再执行foremost xxx.jpg会自动分离；若检测出其他文件修改其后缀名即可，如zip）</p>
</li>
<li><p>5.使用StegSolve对图像进行分通道扫描，查看是否为LSB隐写</p>
</li>
<li><p>6.在kail下切换到F5-steganography，在java Extract运行</p>
</li>
<li><p>命令：java Extract 123456.jpg图片的绝对地址 -p 123456</p>
</li>
<li><p>判断是否为F5算法隐写</p>
</li>
<li><p>7.在kali系统中使用outguess-master工具（需要安装），检测是否为guess算法隐写</p>
</li>
</ul>
<h3 id="算法隐写的具体操作"><a href="#算法隐写的具体操作" class="headerlink" title="算法隐写的具体操作"></a>算法隐写的具体操作</h3><p>1.F5算法隐写</p>
<p>具体操作：在kail下切换到F5-steganography，在java Extract运行</p>
<p>命令：java Extract 123456.jpg图片的绝对地址 -p 123456</p>
<p>2.LSB算法隐写</p>
<p>具体操作：在Stegsolve.jar分析data Extract的red blue green</p>
<p>3.guess算法隐写</p>
<p>具体操作：在kail下切换到outguess目录下，直接用命令即可</p>
<p>命令:outguess -r /root/angrybird.jpg(绝对路径) 123.txt(信息存放的文本)</p>
<h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><h4 id="1-MP3stego"><a href="#1-MP3stego" class="headerlink" title="1.MP3stego"></a>1.MP3stego</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">encode -E hidden_text.txt -P pass svega.wavsvega_stego.mp3</span><br><span class="line"></span><br><span class="line">Decode.exe -X -P pass(密码) svega_stego.mp3(要拷贝到目录下) &#x2F;&#x2F;解码</span><br></pre></td></tr></table></figure>



<h4 id="2-stegdetect"><a href="#2-stegdetect" class="headerlink" title="2.stegdetect"></a>2.stegdetect</h4><p>Stegdetect可以检测到通过JSteg、JPHide、OutGuess、Invisible Secrets、F5、appendX和Camouflage等这些隐写工具隐藏的信息<br>s – 修改检测算法的敏感度，该值的默认值为1。检测结果的匹配度与检测算法的敏感度成正比，算法敏感度的值越大，检测出的可疑文件包含敏感信息的可能性越大。</p>
<p>d – 打印带行号的调试信息。</p>
<p>t – 设置要检测哪些隐写工具（默认检测jopi），可设置的选项如下：</p>
<p>j – 检测图像中的信息是否是用jsteg嵌入的。</p>
<p>o – 检测图像中的信息是否是用outguess嵌入的。</p>
<p>p – 检测图像中的信息是否是用jphide嵌入的。</p>
<p>i – 检测图像中的信息是否是用invisible secrets嵌入的。<br>命令：stegdetect.exe -tjopi -s10.0 xxx.jpg</p>
<p>音频：信息隐藏在声音里(逆序)，信息隐藏在数据里(分析音频数据) —-解题工具 Audition，Matlab</p>
<p>视频：信息隐藏在视频的某个或多个帧里  —解题工具 Premiere</p>
<p>文件隐写：把多个文件拼接成一个  —解题工具 binwalk</p>
<h2 id="加密题"><a href="#加密题" class="headerlink" title="加密题"></a>加密题</h2><h3 id="CTF中的RSA-算法"><a href="#CTF中的RSA-算法" class="headerlink" title="CTF中的RSA 算法"></a>CTF中的RSA 算法</h3><p>1.<strong>质数（素数)**是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。<br> 2.**合数</strong>是指比1大但不是素数的数<br> 3.<strong>约数（因数）</strong>整数a除以整数b(b≠0) 除得的商正好是整数而没有余数，我们就说a能被b整除，或b能整除a。a称为  b的倍数，b称为a的约数</p>
<p> 4.<strong>互质数</strong>：如果两个整数a,b的最大公因数（greatest common divisor）为1，即gcb(a,b)=1，那么称a,b两数互质<br> 5.<strong>欧拉函数</strong>是指设m为正整数，则1,2,3,4…….,m中与m互素的整数的个数记为φ(m)，叫做欧拉函</p>
<hr>
<h3 id="RSA加解密涉及变量"><a href="#RSA加解密涉及变量" class="headerlink" title="RSA加解密涉及变量"></a>RSA加解密涉及变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">N(n):模数（modulus）</span><br><span class="line"></span><br><span class="line">p 和 q ：N的两个因子（factor）</span><br><span class="line"></span><br><span class="line">e 和 d：(密钥) 互为模反数的两个指数（exponent）</span><br><span class="line"></span><br><span class="line">c 和 m：分别是密文和明文，这里一般指的是一个十进制的数还有一个就是n的欧拉函数值</span><br><span class="line"></span><br><span class="line">欧拉函数值：r</span><br><span class="line"></span><br><span class="line">pow(x, y, z)：效果等效pow(x, y)1 % z， 先计算x的y次方，如果存在另一个参数z，需要再对结果进行取模。</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="RSA-密钥流程"><a href="#RSA-密钥流程" class="headerlink" title="RSA 密钥流程"></a>RSA 密钥流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.选择两个大的参数，计算出模数 N &#x3D; p * q</span><br><span class="line"></span><br><span class="line">2.计算欧拉函数 φ &#x3D; (p-1) * (q-1)，然后选择一个e(1&lt;e&lt;φ)，并且e和φ互质（互质：公约数只有1的两个整数）</span><br><span class="line"></span><br><span class="line">3.选一个整数e,满足条件1&lt;e&lt;φ(m),且gcd(φ(m),e)&#x3D;1。</span><br><span class="line"></span><br><span class="line">4.取e的模反数d，计算方法为:e * d ≡ 1 (mod φ) （模反元素：如果两个正整数e和n互质，那么一定可以找到整数d，使得 e * d - 1 被n整除，或者说e * d被n除的余数是1。这时，d就叫做e的“模反元素”。欧拉定理可以用来证明模反元素必然存在。两个整数a,b，它们除以整数M所得的余数相等：a ≡ b(mod m)，比如说5除3余数为2，11除3余数也为2，于是可写成11 ≡ 5(mod 3)。）</span><br><span class="line"></span><br><span class="line">5.对明文m进行加密：c &#x3D; pow(m, e, N),可以得到密文c。</span><br><span class="line"></span><br><span class="line">6.对密文c进行解密：m &#x3D; pow(c, d, N),可以得到明文m。</span><br><span class="line"></span><br><span class="line">7.以&#123;e,n&#125;为公开密钥，&#123;d,n&#125;为秘密密钥。</span><br></pre></td></tr></table></figure>

<p>​          <strong>对于RSA加密算法，公钥{e，n}为公钥，可以任意公开，破解RSA最直接（亦或是暴力）的方法就是分解整数N，然后计算欧拉函数φ(n)=(p-1) * (q-1),再通过d * e ≡ 1 mod φ(N)，即可计算出 d，然后就可以使用私钥{d,n}通过m =  pow(c,d,N)解密明文。</strong></p>
<h3 id="常见攻击方法"><a href="#常见攻击方法" class="headerlink" title="常见攻击方法"></a>常见攻击方法</h3><p><strong>已知<code>p</code>、<code>q</code>、<code>e</code>或者已知<code>n</code>、<code>e</code>求出<code>d</code></strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">p = gmpy2.mpz(<span class="number">18443</span>)<span class="comment">#初始化大整数</span></span><br><span class="line">q = gmpy2.mpz(<span class="number">49891</span>)</span><br><span class="line">e = gmpy2.mpz(<span class="number">19</span>)</span><br><span class="line">phi_n = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi_n)  <span class="comment"># invert（e，r）返回d使得e * d == 1 mod r，如果不存在d，则返回0</span></span><br><span class="line">print(<span class="string">&quot;p=&#123;0&#125;,q=&#123;1&#125;,e=&#123;2&#125;&quot;</span>.format(p,q,e))</span><br><span class="line">print(<span class="string">&quot;d is:\n%s&quot;</span>%d)</span><br></pre></td></tr></table></figure>



<p><strong>已经求出<code>d</code>、<code>n</code>、<code>c</code>，然后可以求出相应的明文m</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#求明文</span><br><span class="line">import gmpy2</span><br><span class="line">n &#x3D; 920139713   #模数</span><br><span class="line">d &#x3D; 96849619    #密钥</span><br><span class="line">c &#x3D; &quot;&quot;&quot;</span><br><span class="line">704796792</span><br><span class="line">752211152</span><br><span class="line">274704164</span><br><span class="line">...  #密文</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">result &#x3D; &quot;&quot;</span><br><span class="line">c_list &#x3D; c.split()</span><br><span class="line">#print(c_list)</span><br><span class="line">for i in c_list:</span><br><span class="line">    result +&#x3D; chr(pow(int(i),d,n))</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<p><strong>已知<code>c</code>、<code>e</code>、<code>n</code>求m</strong></p>
<p>结合以上两种方法，在知道<code>n</code>的前提下可求·<code>p</code>、<code>q</code>,利用<code>p</code>、<code>q</code>、<code>e</code>可以求出<code>d</code>，，从而因为已知<code>d</code>、<code>n</code>、<code>c</code>，求出相应的明文m</p>
<hr>
<p><strong>利用n的公约数</strong></p>
<p>当题目给出若干个模数n1,n2……,且模数很大。如果两次加密的<code>n1</code>和<code>n2</code>具有相同的素因子，那么我们可以利用<code>欧几里德算法</code>直接分解<code>n1</code>和<code>n2</code>.从而计算出两个<code>n</code>的最大公约数<code>p</code>：</p>
<blockquote>
<p>素因子的定义：对于一个数n来说，将它的因子拆到若干个素数相乘，这些素数被称为n的素因子。<br> 比如 12可以被拆为2 6<br> 6不是质数，可以继续拆为2*3<br> 所以最后12的素因子就是 2, 3（不计重复元素）</p>
</blockquote>
<p>识别此类题目，通常会发现题目给了若干个n，均不相同，并且都是2048bit，4096bit级别，无法直接分解<a target="_blank" rel="noopener" href="http://www.factordb.com/index.php%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%98%8E%E6%96%87%E9%83%BD%E6%B2%A1%E4%BB%80%E4%B9%88%E8%81%94%E7%B3%BB%EF%BC%8Ce%E4%B9%9F%E4%B8%80%E8%88%AC%E5%8F%9665537%E3%80%82">http://www.factordb.com/index.php，并且明文都没什么联系，e也一般取65537。</a></p>
<p><img src="https://gitee.com/lin-ziyang/hexo/raw/master/1999159-20200712082911929-729980764.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#-*-coding:utf-8-*-</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">求两个数的最大公约数</span><br><span class="line">算法参考:https:&#x2F;&#x2F;zhidao.baidu.com&#x2F;question&#x2F;36550887.html</span><br><span class="line">by:reborn</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">import gmpy2</span><br><span class="line">n1&#x3D;</span><br><span class="line">n2&#x3D;</span><br><span class="line">def gys1(n1,n2):    #辗转相除法(欧几里德算法)</span><br><span class="line">    if n1&lt;n2:</span><br><span class="line">        n1,n2&#x3D;n2,n1</span><br><span class="line">    while n2!&#x3D;0:</span><br><span class="line">        temp&#x3D;n1%n2</span><br><span class="line">        n1&#x3D;n2</span><br><span class="line">        n2&#x3D;temp</span><br><span class="line">    return n1</span><br><span class="line">def gys2(n1,n2):    #更相减损法</span><br><span class="line">    while n1!&#x3D;n2:</span><br><span class="line">        if n1&lt;n2:</span><br><span class="line">            n1,n2&#x3D;n2,n1</span><br><span class="line">        temp&#x3D;n1-n2</span><br><span class="line">        n1&#x3D;temp</span><br><span class="line">    return n1</span><br><span class="line">p&#x3D;gys2(n1,n2)</span><br><span class="line">print (&quot;p&#x3D;&quot;,p)</span><br><span class="line"></span><br><span class="line">#求q1,q2</span><br><span class="line"></span><br><span class="line">q1&#x3D;n1&#x2F;&#x2F;p</span><br><span class="line">q2&#x3D;n2&#x2F;&#x2F;p</span><br><span class="line">print(&quot;q1&#x3D;&quot;,q1)</span><br><span class="line">print(&quot;q2&#x3D;&quot;,q2)</span><br><span class="line"></span><br><span class="line">#求d_1,d_2</span><br><span class="line"></span><br><span class="line">p0 &#x3D; gmpy2.mpz(p)#初始化大整数</span><br><span class="line">q_1 &#x3D; gmpy2.mpz(q1)</span><br><span class="line">q_2 &#x3D; gmpy2.mpz(q2)</span><br><span class="line">e &#x3D; gmpy2.mpz(65537)</span><br><span class="line">r_1 &#x3D; (p0-1)*(q_1-1)</span><br><span class="line">r_2 &#x3D; (p0-1)*(q_2-1)</span><br><span class="line">d_1 &#x3D; gmpy2.invert(e,r_1)  # invert（e，r）返回d使得e * d &#x3D;&#x3D; 1 mod r，如果不存在d，则返回0</span><br><span class="line">d_2 &#x3D; gmpy2.invert(e,r_2)</span><br><span class="line">print(&quot;d_1&#x3D;&quot;,d_1)</span><br><span class="line">print(&quot;d_2&#x3D;&quot;,d_2)</span><br><span class="line"></span><br><span class="line"># 求c1,c2</span><br><span class="line"></span><br><span class="line">c1&#x3D;</span><br><span class="line">c2&#x3D;</span><br><span class="line">m1 &#x3D; pow(c1, d_1, n1)</span><br><span class="line">m2 &#x3D; pow(c2, d_2, n2)</span><br><span class="line">print(&quot;m1&#x3D;&quot;,m1)</span><br><span class="line">print(&quot;m2&#x3D;&quot;,m2)</span><br></pre></td></tr></table></figure>

<p>根据<code>欧几里德算法</code>算出的<code>p</code>之后，再用<code>n</code>除以<code>p</code>即可求出<code>q</code>，由此可以得到的参数有<code>p</code>、<code>q</code>、<code>n</code>、<code>e</code>，再使用常规方法计算出<code>d</code>，即可破解密文。</p>
<p>m = pow(c, d, N),可以得到明文m</p>
<hr>
<p><strong>共模攻击</strong></p>
<p>如果在RSA的使用中使用了相同的模n对相同的明文m进行了加密，那么就可以在不分解n的情况下还原出明文m的值。</p>
<blockquote>
<p>c1 = m^e1 mod n<br> c2 = m^e2 mod n</p>
</blockquote>
<p>识别：非常简单，若干次加密，每次n都一样，明文根据题意也一样即可。</p>
<hr>
<p><strong>已知私钥文件、c求m</strong></p>
<p>题目中给出了私钥文件private.pem和flag.enc</p>
<p>pem文件通常是包含了—–BEGIN PRIVATE KEY—–和—–END PRIVATE KEY—–，是 Base64 编码的二进制内容<br> 使用私钥解密密文的方式</p>
<p>使用openssl工具<br> 利用如下命令：</p>
<blockquote>
<p>rsautl -decrypt -in flag.enc(密文名称) -inkey private.pem</p>
</blockquote>
<hr>
<p><strong>已知公钥文件、c求m</strong></p>
<p>题目中给出了public.pem和密文flag.enc</p>
<blockquote>
<p>openssl rsa -pubin -text -modulus -in warmup -in pubkey.pem<br> ​     [提取出pubkey.pem中的参数]</p>
</blockquote>
<blockquote>
<p>得到n，化为十进制</p>
</blockquote>
<blockquote>
<p>将n分解为P，q</p>
</blockquote>
<blockquote>
<p>python rsatool.py -o private.pem -e 65537 -p 275127860351348928173285174381581152299 -q 319576316814478949870590164193048041239</p>
<p>[使用rsatool生成私钥文件: private.pem]</p>
</blockquote>
<blockquote>
<p>openssl rsautl -decrypt -in flag.enc -inkey private.pem</p>
</blockquote>
<hr>
<p><strong>低加密指数攻击</strong></p>
<p>在RSA中e也称为加密指数。由于e是可以随意选取的，选取小一点的e可以缩短加密时间，但是选取不当的话，就会造成安全问题。</p>
<p><strong>e=3时的小明文攻击</strong></p>
<p>当e=3时，如果明文过小，导致明文的三次方仍然小于n，那么通过直接对密文三次开方，即可得到明文。</p>
<blockquote>
<p>(1)m3&lt;n,也就是说m3=c;<br> (2)m3&gt;n，即(m3+kn)mod n=c（爆破k，不知道k取什么值）。</p>
</blockquote>
<ul>
<li>第一种情况   根据 <code>c = pow(m, e, N) </code>可知：</li>
</ul>
<p>当e=3时，如果明文过小，导致<strong>明文的三次方</strong>仍然小于n，那么通过直接对密文三次开方，即可得到明文。</p>
<ul>
<li>第二种情况  如果<strong>明文的三次方</strong>比n大，但是不够大，那么设k，有：    c=(m^3+kn)mod n</li>
</ul>
<p>爆破k，如果（c-kn）能开三次根式，那么可以直接得到明文。</p>
<p><strong>识别：</strong></p>
<p>推荐在e=3的时候首先尝试这种方法。</p>
<blockquote>
<p>openssl  rsa  -pubin  -in  pubkey.pem  （读取公钥内容）<br> openssl  rsa   -pubin  in  pubkey.pem -text（以文本格式输出公钥内容),从这一步可以知道e的值</p>
</blockquote>
<p>从而判断为低加密指数攻击</p>
<hr>
<p><strong>低加密指数广播攻击</strong></p>
<p>低加密指数广播攻击，即如果选取的加密指数较低，并且使用了相同的加密指数给一个接收者发送了相同的信息（或者给一群接收者发送了相同的信息），那么可以进行广播攻击得到明文。</p>
<p>假如我们需要将一份明文进行多份加密，但是每份使用不同的密钥，密钥中的模数n不同但指数e相同且很小，我们只要拿到多份密文和对应的n就可以利用<a target="_blank" rel="noopener" href="https://www.cnblogs.com/freinds/p/6388992.html">中国剩余定理</a>进行解密。</p>
<p><strong>适用</strong></p>
<p>只要满足以下情况，我们就可以考虑实用低加密指数广播攻击：</p>
<blockquote>
<p>1.加密指数e非常小<br> 2.一份明文使用不同的模数n，相同的加密指数e进行多次加密<br> 3.可以拿到每一份加密后的密文和对应的模数n、加密指数e</p>
</blockquote>
<p>低加密指数广播攻击脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"># coding:utf8</span><br><span class="line"></span><br><span class="line">from struct import pack,unpack</span><br><span class="line">import zlib</span><br><span class="line">import gmpy</span><br><span class="line">def my_parse_number(number):</span><br><span class="line">    string &#x3D; &quot;%x&quot; % number</span><br><span class="line">    #if len(string) !&#x3D; 64:</span><br><span class="line">    #    return &quot;&quot;</span><br><span class="line">    erg &#x3D; []</span><br><span class="line">    while string !&#x3D; &#39;&#39;:</span><br><span class="line">        erg &#x3D; erg + [chr(int(string[:2], 16))]</span><br><span class="line">        string &#x3D; string[2:]</span><br><span class="line">    return &#39;&#39;.join(erg)</span><br><span class="line">def extended_gcd(a, b):</span><br><span class="line">    x,y &#x3D; 0, 1</span><br><span class="line">    lastx, lasty &#x3D; 1, 0</span><br><span class="line">    while b:</span><br><span class="line">        a, (q, b) &#x3D; b, divmod(a,b)</span><br><span class="line">        x, lastx &#x3D; lastx-q*x, x</span><br><span class="line">        y, lasty &#x3D; lasty-q*y, y</span><br><span class="line">    return (lastx, lasty, a)</span><br><span class="line">def chinese_remainder_theorem(items):</span><br><span class="line">  N &#x3D; 1</span><br><span class="line">  for a, n in items:</span><br><span class="line">    N *&#x3D; n</span><br><span class="line">  result &#x3D; 0</span><br><span class="line">  for a, n in items:</span><br><span class="line">    m &#x3D; N&#x2F;n</span><br><span class="line">    r, s, d &#x3D; extended_gcd(n, m)</span><br><span class="line">    if d !&#x3D; 1:</span><br><span class="line">      N&#x3D;N&#x2F;n</span><br><span class="line">      continue</span><br><span class="line">      #raise &quot;Input not pairwise co-prime&quot;</span><br><span class="line">    result +&#x3D; a*s*m</span><br><span class="line">  return result % N, N</span><br><span class="line">  &#x2F;&#x2F;中国剩余定理 ， 输入多组c和多组n，以及较小的指数e</span><br><span class="line">sessions&#x3D;[</span><br><span class="line">&#123;&quot;c&quot;: , &quot;e&quot;: , &quot;n&quot;: &#125;,</span><br><span class="line">&#123;&quot;c&quot;: , &quot;e&quot;: , &quot;n&quot;: &#125;,</span><br><span class="line">&#123;&quot;c&quot;: , &quot;e&quot;: , &quot;n&quot;: &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">data &#x3D; []</span><br><span class="line">for session in sessions:</span><br><span class="line">    e&#x3D;session[&#39;e&#39;]</span><br><span class="line">    n&#x3D;session[&#39;n&#39;]</span><br><span class="line">    msg&#x3D;session[&#39;c&#39;]</span><br><span class="line">    data &#x3D; data + [(msg, n)]</span><br><span class="line">print &quot;Please wait, performing CRT&quot;</span><br><span class="line">x, n &#x3D; chinese_remainder_theorem(data)</span><br><span class="line">e&#x3D;session[&#39;e&#39;]</span><br><span class="line">realnum &#x3D; gmpy.mpz(x).root(e)[0].digits()</span><br><span class="line">print my_parse_number(int(realnum))</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>n可以分解为多个素数</strong></p>
<p>使用公钥加密和使用私钥解密流程（中国剩余定理）：<br> 准备<br> 首先，我们需要在在生成私钥公钥时，多生成几个数：<br> 我们的d是e对phi(n)的逆元，我们现在需要另外2个逆元（分别是对(p-1)和(q-1)的），既<br> 1：计算dp，使得dp * e = 1 mod(p-1)<br> 2：计算dq，使得dq * e = 1 mod(q-1)<br> 此外需要第三个元素，既q对p的逆元<br> 3：计算qInv，使得qInv * q = 1 mod p<br> ​        1 2 3 都作为私钥的一部分。</p>
<blockquote>
<p>dp = d mod p-1<br> dq = d mod q-1</p>
</blockquote>
<p><strong>计算：</strong></p>
<p>使用公钥加密：<br> 若要加密明文m,则需要计算c = m^e mod n，c为密文。</p>
<p>使用私钥解密：<br> 1:m1=c^dp mod p<br> 2:m2=c^dq mod q<br> 3:h= (qInv*((m1 - m2)mod p)) mod p<br> 4:m = m2 + h*q<br> m就是明文。</p>
<p>例：n=17947<br> ​           e=3<br> ​           c=8363<br> ​           m=???</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">n&#x3D;17947</span><br><span class="line">p&#x3D;137</span><br><span class="line">q&#x3D;131</span><br><span class="line">e&#x3D;3</span><br><span class="line">c&#x3D;8363</span><br><span class="line">dp&#x3D;gmpy2.invert(e,p-1)</span><br><span class="line">dq&#x3D;gmpy2.invert(e,q-1)</span><br><span class="line">m1&#x3D;pow(c,dp,p)</span><br><span class="line">m2&#x3D;pow(c,dq,q)</span><br><span class="line">qInv&#x3D;gmpy2.invert(q,p)</span><br><span class="line">h&#x3D;(qInv*((m1-m2)% p)) % p</span><br><span class="line">m&#x3D;m2+h*q</span><br><span class="line">print(m)</span><br></pre></td></tr></table></figure>

<p><strong>多素数</strong></p>
<p>例:n=p1<em>p2</em>p3=2279269<br> ​     p1=137<br> ​     p2=131<br> ​     p3=127<br> ​     e=19</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">预先计算:</span><br><span class="line">dp &#x3D; 19^-1 mod 137-1 &#x3D; 43</span><br><span class="line">dq &#x3D; 19^-1 mod 131-1 &#x3D; 89</span><br><span class="line">dr &#x3D; 19^-1 mod 127-1 &#x3D; 73</span><br><span class="line"></span><br><span class="line">若要解密密文 768924，则先计算</span><br><span class="line">1:m1&#x3D;768924^43 mod 137 &#x3D; 102</span><br><span class="line">2:m2&#x3D;768924^89 mod 131 &#x3D; 120</span><br><span class="line">3:m3&#x3D;768924^73 mod 127 &#x3D; 5</span><br><span class="line"></span><br><span class="line">等式1与等式2连列方程组计算：</span><br><span class="line">qInv &#x3D; 114</span><br><span class="line">h &#x3D; (qInv*((m1 - m2)mod p)) mod p &#x3D; 3</span><br><span class="line">m12 &#x3D; m2 + h*q &#x3D; 120 + 3*131 &#x3D; 513</span><br><span class="line"></span><br><span class="line">所以等式1与等式2的通用解为：513+k1*(131*137)</span><br><span class="line">所以结合等式3问题可以变为：</span><br><span class="line">m1&#x3D;513  p&#x3D;17947</span><br><span class="line">m2&#x3D;5    q&#x3D;127</span><br><span class="line">qInv*q≡ 1 mod p    ——&gt;qInv&#x3D;10316</span><br><span class="line">h &#x3D; (10316*((513 - 5)mod 17947)) mod 17947 &#x3D;4</span><br><span class="line">m &#x3D; 5 + 4*127 &#x3D; 513</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>jiaoben</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">n&#x3D;2279269</span><br><span class="line">p1&#x3D;137</span><br><span class="line">p2&#x3D;131</span><br><span class="line">p3&#x3D;127</span><br><span class="line">e&#x3D;19</span><br><span class="line">c&#x3D;768924</span><br><span class="line">dp1&#x3D;gmpy2.invert(e,p1-1)</span><br><span class="line">dp2&#x3D;gmpy2.invert(e,p2-1)</span><br><span class="line">dp3&#x3D;gmpy2.invert(e,p3-1)</span><br><span class="line">m1&#x3D;pow(c,dp1,p1)</span><br><span class="line">m2&#x3D;pow(c,dp2,p2)</span><br><span class="line">m3&#x3D;pow(c,dp3,p3)</span><br><span class="line">qInv1&#x3D;gmpy2.invert(p2,p1)</span><br><span class="line">h1&#x3D;(qInv1*((m1-m2) % p1)) % p1</span><br><span class="line">m4&#x3D;m2+h1*p2</span><br><span class="line">p4&#x3D;p1*p2</span><br><span class="line">qInv2&#x3D;gmpy2.invert(p3,p4)</span><br><span class="line">h2&#x3D;(qInv2*((m4-m3)% p4)) % p4</span><br><span class="line">m&#x3D;m3+h2*p3</span><br><span class="line">print(m)</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>dp、dq泄露</strong></p>
<blockquote>
<p>dp = d mod p-1<br> dq = d mod q-1</p>
</blockquote>
<p>这种参数是为了让解密的时候更快速而产生的</p>
<p>已知p,q,dp,dq,c求m</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import binascii</span><br><span class="line">import libnum</span><br><span class="line">def decrypt(dp,dq,p,q,c):</span><br><span class="line">    InvQ &#x3D; gmpy2.invert(q,p)</span><br><span class="line">    mp &#x3D; pow(c,dp,p)</span><br><span class="line">    mq &#x3D; pow(c,dq,q)                   #求幂取模运算</span><br><span class="line">    m&#x3D;(((mp-mq)*InvQ)%p)*q+mq          #求明文公式</span><br><span class="line">    print (binascii.unhexlify(hex(m)[2:]))</span><br><span class="line">    print(libnum.n2s(m))</span><br><span class="line">p &#x3D; </span><br><span class="line">q &#x3D; </span><br><span class="line">dp &#x3D; </span><br><span class="line">dq &#x3D; </span><br><span class="line">c &#x3D; </span><br><span class="line">decrypt(dp,dq,p,q,c)</span><br></pre></td></tr></table></figure>

<p><strong>已知e,n,dp,c求m</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">import binascii</span><br><span class="line">def getd(n,e,dp):</span><br><span class="line">    for i in range(1,e):            #在范围(1,e)之间进行遍历</span><br><span class="line">        if (dp*e-1)%i &#x3D;&#x3D; 0:</span><br><span class="line">            if n%(((dp*e-1)&#x2F;i)+1)&#x3D;&#x3D;0:    #存在p，使得n能被p整除</span><br><span class="line">                p&#x3D;((dp*e-1)&#x2F;i)+1</span><br><span class="line">                q&#x3D;n&#x2F;(((dp*e-1)&#x2F;i)+1)</span><br><span class="line">                phi &#x3D; (p-1)*(q-1)         #欧拉定理</span><br><span class="line">                d &#x3D; gmpy2.invert(e,phi)%phi        #求模逆</span><br><span class="line">                return d</span><br><span class="line">e &#x3D;</span><br><span class="line">n &#x3D; </span><br><span class="line">dp &#x3D; </span><br><span class="line">c &#x3D; </span><br><span class="line">d&#x3D;getd(n,e,dp)</span><br><span class="line">m&#x3D;pow(c,d,n)                            #快速求幂取模运算</span><br><span class="line">print(binascii.unhexlify(hex(m)[2:]))       #16进制转文本</span><br><span class="line">print(libnum.n2s(m))</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>已知n,r求p,q</strong></p>
<p>核心是通过n和r解出p和q</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.二分法，求得p，q</span><br><span class="line"></span><br><span class="line">2.RSATool2v17中，输入p，q，r，e，得到d  (脚本也可)</span><br><span class="line"></span><br><span class="line">3.通过m&#x3D;pow(c,d,n)</span><br><span class="line">注意：有时题目有要求，解出的可能是m乘上某一个参数，这是需要仔细审题</span><br><span class="line"></span><br><span class="line">4.转字符，得到flag</span><br></pre></td></tr></table></figure>

<p>脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import numpy as np</span><br><span class="line">np.set_printoptions(suppress&#x3D;True)</span><br><span class="line"></span><br><span class="line">n&#x3D;gmpy2.mpz(14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199...)</span><br><span class="line">r&#x3D;gmpy2.mpz(14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199...)</span><br><span class="line"></span><br><span class="line">c1&#x3D;n-r+1</span><br><span class="line">print (c1)</span><br><span class="line"></span><br><span class="line">l&#x3D;c1&#x2F;2</span><br><span class="line">r&#x3D;c1</span><br><span class="line">#p&#x3D;(l+r)&#x2F;2</span><br><span class="line">#y&#x3D;p*(c1-p)</span><br><span class="line"></span><br><span class="line">while l&lt;r:</span><br><span class="line">	p&#x3D;(l+r)&#x2F;2</span><br><span class="line">	y&#x3D;p*(c1-p)</span><br><span class="line">	if y&#x3D;&#x3D;n:</span><br><span class="line">		print (p)</span><br><span class="line">		break</span><br><span class="line">	if y&gt;n:</span><br><span class="line">		print (y&gt;n)</span><br><span class="line">		l&#x3D;p</span><br><span class="line">	else:</span><br><span class="line">		print (y&lt;n)</span><br><span class="line">		r&#x3D;p</span><br><span class="line">		print (&quot;done&quot;)</span><br><span class="line">q&#x3D;c1-p</span><br><span class="line">print q</span><br><span class="line">&#x2F;*</span><br><span class="line">if p&gt;q:</span><br><span class="line">    p,q&#x3D;q,p</span><br><span class="line">factor2 &#x3D; 2021 * p + 2020 * q</span><br><span class="line">if factor2 &lt; 0:</span><br><span class="line">    factor2 &#x3D; (-1) * factor2</span><br><span class="line">    </span><br><span class="line">_P&#x3D;sympy.nextprime(factor2)</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://ggken753.github.io/2020/11/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07/" data-id="ckhytgorg00005kv3f15wav1t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/11/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          90道MISC部分
        
      </div>
    </a>
  
  
    <a href="/2020/11/19/%E6%B5%B7%E5%95%B8%E6%9D%AFwp/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">海啸杯wp</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08/">90道MISC部分</a>
          </li>
        
          <li>
            <a href="/2020/11/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07/">MISC解题思路</a>
          </li>
        
          <li>
            <a href="/2020/11/19/%E6%B5%B7%E5%95%B8%E6%9D%AFwp/">海啸杯wp</a>
          </li>
        
          <li>
            <a href="/2020/11/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06/">漏洞</a>
          </li>
        
          <li>
            <a href="/2020/11/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05/">SQL注入</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>